import * as Dialog from "@radix-ui/react-dialog";
import { Check, GripVertical, Loader2, Pencil, X } from "lucide-react";
import React, { useCallback, useEffect, useRef, useState } from 'react';

import { useWorkspaceState } from '../hooks/use-workspace-state';
import { WorkspaceState } from '../types/file-types';
import type { AppState } from '../hooks/use-app-state';
import { STORAGE_KEYS } from '../constants';
import { WORKSPACE_ITEM, WORKSPACE_DRAG_SCROLL, WORKSPACE_TRANSFORMS } from '../constants/workspace-drag-constants';
import { safeJsonParse } from '../utils/local-storage-utils';
import { 
  getWorkspaceSortMode, 
  setWorkspaceSortMode, 
  getWorkspaceManualOrder, 
  setWorkspaceManualOrder, 
  sortWorkspaces, 
  moveWorkspace,
  WorkspaceSortMode,
  WorkspaceInfo
} from '../utils/workspace-sorting';

interface WorkspaceModalProps {
  isOpen: boolean;
  onClose: () => void;
  initialRenameTarget?: string | null;
  onClearInitialRenameTarget?: () => void;
  appState: AppState;
}

const WorkspaceModal = ({ 
  isOpen, 
  onClose, 
  initialRenameTarget, 
  onClearInitialRenameTarget,
  appState
}: WorkspaceModalProps): JSX.Element => {
  const { 
    saveWorkspace: persistWorkspace, 
    loadWorkspace: loadPersistedWorkspace, 
    deleteWorkspace: deletePersistedWorkspace, 
    renameWorkspace: renamePersistedWorkspace,
    getWorkspaceNames 
  } = useWorkspaceState();
  const [name, setName] = useState("" as string);
  const [newName, setNewName] = useState("" as string);
  const [workspaceNames, setWorkspaceNames] = useState([] as string[]);
  const [renamingWsName, setRenamingWsName] = useState(null as string | null);
  const [saveState, setSaveState] = useState('idle');
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const nameInputRef = useRef<HTMLInputElement | null>(null);
  const renameInputRef = useRef<HTMLInputElement | null>(null);
  const [selectedWorkspaces, setSelectedWorkspaces] = useState<Set<string>>(new Set());
  const [selectAllChecked, setSelectAllChecked] = useState(false);
  const [sortMode, setSortMode] = useState<WorkspaceSortMode>(() => getWorkspaceSortMode());
  const [manualOrder, setManualOrder] = useState<string[]>(() => {
    const order = getWorkspaceManualOrder();
    return order;
  });
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);
  const workspaceListRef = useRef<HTMLDivElement | null>(null);
  const scrollIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const refreshWorkspaceList = useCallback(() => {
    const names = getWorkspaceNames();
    setWorkspaceNames(names);
  }, [getWorkspaceNames]);

  const getSortedWorkspaces = useCallback((): string[] => {
    const workspacesString = localStorage.getItem(STORAGE_KEYS.WORKSPACES);
    const workspaces = safeJsonParse(workspacesString, {});
    
    const workspaceInfos: WorkspaceInfo[] = Object.entries(workspaces).map(([name, data]: [string, any]) => {
      let savedAt = 0;
      if (typeof data === 'string') {
        try {
          const parsed = safeJsonParse(data, { savedAt: 0 });
          savedAt = parsed.savedAt || 0;
        } catch {
          // Ignore parse errors
        }
      } else if (data && typeof data === 'object') {
        savedAt = data.savedAt || 0;
      }
      return { name, savedAt };
    });
    
    const sorted = sortWorkspaces(workspaceInfos, sortMode, manualOrder);
    return sorted;
  }, [sortMode, manualOrder]);

  const handleSortModeChange = useCallback((newMode: WorkspaceSortMode) => {
    if (newMode === 'manual') {
      // When switching to manual, preserve the current order
      const currentOrder = getSortedWorkspaces();
      setManualOrder(currentOrder);
      setWorkspaceManualOrder(currentOrder);
    }
    setSortMode(newMode);
    setWorkspaceSortMode(newMode);
  }, [getSortedWorkspaces]);

  const handleToggleWorkspace = useCallback((workspaceName: string) => {
    setSelectedWorkspaces((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(workspaceName)) {
        newSet.delete(workspaceName);
      } else {
        newSet.add(workspaceName);
      }
      // Update select all state based on selection
      setSelectAllChecked(newSet.size === workspaceNames.length && workspaceNames.length > 0);
      return newSet;
    });
  }, [workspaceNames]);

  const handleSelectAll = useCallback(() => {
    if (selectAllChecked) {
      // Unselect all
      setSelectedWorkspaces(new Set());
      setSelectAllChecked(false);
    } else {
      // Select all
      setSelectedWorkspaces(new Set(workspaceNames));
      setSelectAllChecked(true);
    }
  }, [selectAllChecked, workspaceNames]);

  const handleBulkDelete = useCallback(() => {
    const count = selectedWorkspaces.size;
    if (count === 0) return;

    const message = count === 1 
      ? 'Are you sure you want to delete 1 workspace? This cannot be undone.'
      : 'Are you sure you want to delete PLACEHOLDER workspaces? This cannot be undone.';

    if (window.confirm(message)) {
      for (const wsName of selectedWorkspaces) {
        deletePersistedWorkspace(wsName);
      }
      setSelectedWorkspaces(new Set());
      setSelectAllChecked(false);
      refreshWorkspaceList();
    }
  }, [selectedWorkspaces, deletePersistedWorkspace, refreshWorkspaceList]);
  
  const handleRenameStart = (wsName: string) => {
    setRenamingWsName(wsName);
    setNewName(wsName); // Pre-fill input with current name
  };

  const handleRenameCancel = () => {
    setRenamingWsName(null);
    setNewName('');
  };
  
  const handleDragStart = useCallback((e: React.DragEvent, index: number) => {
    // If not in manual mode, switch to it and preserve current order
    if (sortMode !== 'manual') {
      const currentOrder = getSortedWorkspaces();
      setManualOrder(currentOrder);
      setWorkspaceManualOrder(currentOrder);
      setSortMode('manual');
      setWorkspaceSortMode('manual');
    }
    setDraggedIndex(index);
    e.dataTransfer.effectAllowed = 'move';
  }, [sortMode, getSortedWorkspaces]);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    // Auto-scroll functionality
    if (!workspaceListRef.current) return;
    
    const container = workspaceListRef.current;
    const containerRect = container.getBoundingClientRect();
    const mouseY = e.clientY;
    
    // Define scroll zones
    const scrollZoneSize = WORKSPACE_DRAG_SCROLL.ZONE_SIZE;
    const scrollSpeed = WORKSPACE_DRAG_SCROLL.BASE_SPEED;
    
    // Clear any existing scroll interval
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
    
    // Check if we're in the top scroll zone
    if (mouseY < containerRect.top + scrollZoneSize) {
      const intensity = 1 - (mouseY - containerRect.top) / scrollZoneSize;
      scrollIntervalRef.current = setInterval(() => {
        container.scrollTop -= scrollSpeed * (1 + intensity * WORKSPACE_DRAG_SCROLL.SPEED_MULTIPLIER);
      }, WORKSPACE_DRAG_SCROLL.INTERVAL_MS);
    }
    // Check if we're in the bottom scroll zone
    else if (mouseY > containerRect.bottom - scrollZoneSize) {
      const intensity = 1 - (containerRect.bottom - mouseY) / scrollZoneSize;
      scrollIntervalRef.current = setInterval(() => {
        container.scrollTop += scrollSpeed * (1 + intensity * WORKSPACE_DRAG_SCROLL.SPEED_MULTIPLIER);
      }, WORKSPACE_DRAG_SCROLL.INTERVAL_MS);
    }
  }, []);
  
  const handleDragOverItem = useCallback((e: React.DragEvent, index: number) => {
    e.preventDefault();
    e.stopPropagation();
    if (draggedIndex === null || draggedIndex === index) return;
    setDragOverIndex(index);
  }, [draggedIndex]);
  
  const handleDragEnter = useCallback((e: React.DragEvent, index: number) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  const handleDrop = useCallback((e: React.DragEvent, dropIndex: number) => {
    e.preventDefault();
    if (draggedIndex === null) return;
    
    // Clear any active scroll interval
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
    
    // Use dragOverIndex if we have it, otherwise use dropIndex
    const targetIndex = dragOverIndex !== null ? dragOverIndex : dropIndex;
    
    if (draggedIndex === targetIndex) {
      setDraggedIndex(null);
      setDragOverIndex(null);
      return;
    }
    
    const sortedNames = getSortedWorkspaces();
    
    const newOrder = moveWorkspace(sortedNames, draggedIndex, targetIndex);
    
    // Update both state and localStorage
    setManualOrder(newOrder);
    setWorkspaceManualOrder(newOrder);
    
    setDraggedIndex(null);
    setDragOverIndex(null);
  }, [draggedIndex, dragOverIndex, getSortedWorkspaces]);

  const handleDragEnd = useCallback((e: React.DragEvent) => {
    
    // If we have a dragOverIndex, use it to reorder (fallback for when drop doesn't fire)
    if (draggedIndex !== null && dragOverIndex !== null && draggedIndex !== dragOverIndex) {
      const sortedNames = getSortedWorkspaces();
      
      const newOrder = moveWorkspace(sortedNames, draggedIndex, dragOverIndex);
      
      setManualOrder(newOrder);
      setWorkspaceManualOrder(newOrder);
    }
    
    setDraggedIndex(null);
    setDragOverIndex(null);
    
    // Clear any active scroll interval
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
  }, [draggedIndex, dragOverIndex, getSortedWorkspaces]);
  
  const handleDragLeave = useCallback((e: React.DragEvent) => {
    // Only stop scrolling if we're leaving the container itself
    if (e.currentTarget === e.target) {
      if (scrollIntervalRef.current) {
        clearInterval(scrollIntervalRef.current);
        scrollIntervalRef.current = null;
      }
    }
  }, []);

  useEffect(() => {
    if (isOpen) {
      refreshWorkspaceList();
      setName(''); // Reset save input
      setRenamingWsName(null); // Reset renaming state
      setNewName(''); // Reset rename input
      setSelectedWorkspaces(new Set()); // Reset selection
      setSelectAllChecked(false); // Reset select all

      // Check if we need to start in rename mode
      if (initialRenameTarget && onClearInitialRenameTarget) {
        // Need a slight delay or ensure the list is rendered before starting rename
        // Using setTimeout to ensure the component has rendered and state updates are processed
        setTimeout(() => {
            handleRenameStart(initialRenameTarget);
            onClearInitialRenameTarget(); // Clear the target in the parent state
        }, 0); 
      }
    }
  }, [isOpen, refreshWorkspaceList, initialRenameTarget, onClearInitialRenameTarget]); // Added dependencies

  useEffect(() => {
    // Focus the rename input when renaming starts
    if (renamingWsName && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [renamingWsName]);


  // Clear timeout on unmount or when modal closes
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      if (scrollIntervalRef.current) {
        clearInterval(scrollIntervalRef.current);
      }
    };
  }, []);

  const handleSave = () => {
    const trimmedName = name.trim();
    if (!trimmedName) {
        alert("Please enter a workspace name.");
        return;
    }

    setSaveState('saving'); // Indicate saving process start

    // Clear any existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    if (workspaceNames.includes(trimmedName)) {
        if (!window.confirm('Workspace "PLACEHOLDER" already exists. Overwrite?')) {
            return;
        }
    }

    const workspaceToSave: WorkspaceState = {
      selectedFolder: appState.selectedFolder,
      expandedNodes: appState.expandedNodes,
      selectedFiles: appState.selectedFiles,
      userInstructions: appState.userInstructions,
      allFiles: appState.allFiles || [],
      sortOrder: appState.sortOrder || "name",
      searchTerm: appState.searchTerm || "",
      fileTreeMode: appState.fileTreeMode || "none",
      exclusionPatterns: appState.exclusionPatterns || [],
      tokenCounts: (() => {
        const acc: { [filePath: string]: number } = {};
        for (const file of appState.selectedFiles) {
          acc[file.path] = file.tokenCount || 0;
        }
        return acc;
      })(),
      customPrompts: {
        systemPrompts: appState.selectedSystemPrompts,
        rolePrompts: appState.selectedRolePrompts
      }
    };

    try {
      persistWorkspace(trimmedName, workspaceToSave);
      setSaveState('success'); // Set state to success
      refreshWorkspaceList(); // Refresh list *after* successful save

      // Set timeout to revert state and clear the form, keeping the modal open
      saveTimeoutRef.current = setTimeout(() => {
        setSaveState('idle');
        setName(''); // Clear the input field
      }, 1500); // Duration for the checkmark visibility

    } catch (error) {
      setSaveState('idle'); // Revert to idle on error
      alert('Failed to save workspace "PLACEHOLDER".");
      // Optionally add an 'error' state if more specific feedback is needed
    }
  };
  
  const handleDelete = (wsName: string) => {
    const message = 'Are you sure you want to delete workspace "' + wsName + '"? This cannot be undone.';
    if (window.confirm(message)) {
      deletePersistedWorkspace(wsName);
      refreshWorkspaceList();
    }
  };

  const handleLoad = (wsName: string) => {
    try {
      const workspaceData = loadPersistedWorkspace(wsName);
      if (workspaceData) {
        window.dispatchEvent(new CustomEvent('workspaceLoaded', { detail: { name: wsName, workspace: workspaceData } }));
        onClose();
      } else {
        // No alert - workspace has been auto-deleted if corrupted
        refreshWorkspaceList(); // Refresh the list to remove the corrupted workspace
      }
    } catch (error) {
      // No alert - just log the error
      refreshWorkspaceList(); // Refresh the list to remove the corrupted workspace
    }
  };
 
  const handleRenameConfirm = () => {
    if (!renamingWsName || !newName.trim() || renamingWsName === newName.trim()) {
      handleRenameCancel(); // Exit rename mode if names are same or new name is empty
      return;
    }
    const trimmedNewName = newName.trim();
    
    // Check if new name already exists (excluding the one being renamed)
    if (workspaceNames.filter((name: string) => name !== renamingWsName).includes(trimmedNewName)) { // Added type annotation
        alert('Workspace name "PLACEHOLDER" already exists. Please choose a different name.');
        return; // Keep rename mode active for user to correct
    }

    const success = renamePersistedWorkspace(renamingWsName, trimmedNewName);
    if (success) {
      refreshWorkspaceList();
      handleRenameCancel(); // Exit rename mode
    } else {
      // Error likely logged in the hook, maybe show an alert here too
      alert('Failed to rename workspace "PLACEHOLDER".');
      // Optionally keep rename mode active or cancel
      // handleRenameCancel(); 
    }
  };

  // Function to generate class name for the apply button
  const getApplyButtonClassName = () => {
    let className = "apply-button save-button";
    if (saveState !== 'idle') {
      className += ' save-PLACEHOLDER';
    }
    return className;
  };

  // Function to generate title for the apply button
  const getApplyButtonTitle = () => {
    if (renamingWsName) {
      return "Complete or cancel the current rename operation first";
    }
    if (saveState === 'saving') {
      return "Saving...";
    }
    if (saveState === 'success') {
      return "Saved!";
    }
    return workspaceNames.includes(name.trim()) ? 'Overwrite Workspace' : 'Save Workspace';
  };

  // Function to determine the button text content
  const getApplyButtonText = () => {
    return workspaceNames.includes(name.trim()) ? 'Overwrite Workspace' : 'Save Workspace';
  };

  return (
    <Dialog.Root open={isOpen} onOpenChange={(open: boolean) => !open && onClose()}>
      <Dialog.Portal>
        <Dialog.Overlay className="modal-overlay" />
        <Dialog.Content className="modal-content workspace-modal" aria-describedby={undefined}>
          <div className="modal-header">
            <Dialog.Title asChild>
              <h2>Manage Workspaces</h2>
            </Dialog.Title>
            <Dialog.Close asChild>
              <button className="close-button"><X size={16} /></button>
            </Dialog.Close>
          </div>
          
          <div className="modal-body">
            <div className="workspace-form">
              <input
                type="text"
                className="prompt-title-input"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Enter workspace name"
                disabled={!!renamingWsName} // Disable if renaming is active
                title={renamingWsName ? "Complete or cancel the current rename operation first" : "Enter workspace name"}
                ref={nameInputRef}
              />
              <button 
                className={getApplyButtonClassName()}
                onClick={handleSave}
                disabled={!name.trim() || !!renamingWsName || saveState === 'saving' || saveState === 'success'} // Disable during saving/success/renaming
                title={getApplyButtonTitle()}
                style={{ position: 'relative', overflow: 'hidden' }} // Needed for absolute positioning of icon
              >
                <span className={'button-text PLACEHOLDER'}>
                  {getApplyButtonText()}
                </span>
                 {saveState === 'saving' && (
                  <Loader2 size={16} className="button-icon spin" />
                )}
                {saveState === 'success' && (
                  <Check size={16} className="button-icon success-check" />
                )}
              </button>
              
              <div className="workspace-header">
                <div className="workspace-header-left">
                  <h3 className="workspace-subtitle">Saved Workspaces</h3>
                  {workspaceNames.length > 0 && (
                    <div className="workspace-sort-selector">
                      <select
                        value={sortMode}
                        onChange={(e) => handleSortModeChange(e.target.value as WorkspaceSortMode)}
                        className="workspace-sort-dropdown"
                      >
                        <option value="recent">Most Recent</option>
                        <option value="alphabetical">Alphabetical</option>
                        <option value="manual">Manual Order</option>
                      </select>
                    </div>
                  )}
                </div>
                {workspaceNames.length > 0 && (
                  <div className="workspace-select-all">
                    <div className="workspace-checkbox-container">
                      <input
                        type="checkbox"
                        id="workspace-select-all"
                        className="tree-item-checkbox"
                        checked={selectAllChecked}
                        onChange={handleSelectAll}
                      />
                      <label htmlFor="workspace-select-all" className="custom-checkbox" aria-label="Select all workspaces" />
                    </div>
                    <label htmlFor="workspace-select-all" className="select-all-label">Select All</label>
                  </div>
                )}
              </div>
              
              {selectedWorkspaces.size > 0 && (
                <div className="bulk-actions-bar">
                  <span className="selected-count">
                    {selectedWorkspaces.size} workspace{selectedWorkspaces.size === 1 ? '' : 's'} selected
                  </span>
                  <div className="bulk-actions">
                    <button 
                      className="bulk-action-button delete"
                      onClick={handleBulkDelete}
                    >
                      Delete Selected
                    </button>
                    <button 
                      className="bulk-action-button clear"
                      onClick={() => {
                        setSelectedWorkspaces(new Set());
                        setSelectAllChecked(false);
                      }}
                    >
                      Clear Selection
                    </button>
                  </div>
                </div>
              )}
              
              {workspaceNames.length === 0 ? (
                <div className="no-prompts-message">
                  No workspaces saved yet.
                </div>
              ) : (
                <div 
                  className="workspace-list" 
                  ref={workspaceListRef}
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                >
                  {getSortedWorkspaces().map((wsName: string, index: number) => {
                    const isDragging = draggedIndex === index;
                    const isDragOver = dragOverIndex === index;
                    const shouldShowGap = isDragOver && draggedIndex !== null && draggedIndex !== index;
                    
                    return (
                      <div 
                        key={wsName} 
                        className={'workspace-item draggable PLACEHOLDER PLACEHOLDER'}
                        draggable={renamingWsName !== wsName}
                        onDragStart={(e) => handleDragStart(e, index)}
                        onDragEnter={(e) => handleDragEnter(e, index)}
                        onDragOver={(e) => handleDragOverItem(e, index)}
                        onDrop={(e) => handleDrop(e, index)}
                        onDragEnd={handleDragEnd}
                        style={{
                          transform: (() => {
                            if (draggedIndex === null) return 'translateY(0)';
                            if (dragOverIndex === null) return 'translateY(0)';
                            
                            // Create space for the dragged item
                            if (draggedIndex < dragOverIndex) {
                              // Dragging down
                              if (index > draggedIndex && index <= dragOverIndex) {
                                return WORKSPACE_TRANSFORMS.MOVE_UP;
                              }
                            } else {
                              // Dragging up
                              if (index < draggedIndex && index >= dragOverIndex) {
                                return WORKSPACE_TRANSFORMS.MOVE_DOWN;
                              }
                            }
                            return WORKSPACE_TRANSFORMS.NO_TRANSFORM;
                          })(),
                          transition: 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
                        }}
                      >
                      <div className="drag-handle">
                        <GripVertical size={16} />
                      </div>
                      <div className="workspace-checkbox-container">
                        <input
                          type="checkbox"
                          id={'workspace-checkbox-PLACEHOLDER'}
                          className="tree-item-checkbox"
                          checked={selectedWorkspaces.has(wsName)}
                          onChange={() => handleToggleWorkspace(wsName)}
                          onClick={(e) => e.stopPropagation()}
                        />
                        <label 
                          htmlFor={'workspace-checkbox-PLACEHOLDER'} 
                          className="custom-checkbox"
                          aria-label={'Select PLACEHOLDER'}
                        />
                      </div>
                      {renamingWsName === wsName ? (
                        // Renaming UI
                        <>
                          <div className="prompt-details flex-grow"> 
                            <input
                              type="text"
                              className="prompt-title-input flex-grow" // Use similar styling
                              value={newName}
                              onChange={(e) => setNewName(e.target.value)}
                              onKeyDown={(e) => e.key === 'Enter' && handleRenameConfirm()}
                              ref={renameInputRef}
                            />
                          </div>
                          <div className="workspace-actions">
                            <button 
                              className="prompt-action-button confirm-button" // Style as needed
                              onClick={handleRenameConfirm}
                              title="Confirm rename"
                              disabled={!newName.trim() || (newName.trim() === wsName)}
                            >
                              <Check size={16} />
                            </button>
                            <button 
                              className="prompt-action-button cancel-button" // Style as needed
                              onClick={handleRenameCancel}
                              title="Cancel rename"
                            >
                              <X size={16} />
                            </button>
                          </div>
                        </>
                      ) : (
                        // Default display UI
                        <>
                          <div className="prompt-details">
                            <div className="prompt-title">{wsName}</div>
                          </div>
                          <div className="workspace-actions">
                            <button 
                              className="prompt-action-button"
                              onClick={() => handleLoad(wsName)}
                              title="Load workspace"
                            >
                              Load
                            </button>
                             <button 
                              className="prompt-action-button rename-button" // Style as needed
                              onClick={() => handleRenameStart(wsName)}
                              title="Rename workspace"
                            >
                              <Pencil size={16} /> 
                            </button>
                            <button 
                              className="prompt-action-button delete-button"
                              onClick={() => handleDelete(wsName)}
                              title="Delete workspace"
                            >
                              <X size={16} />
                            </button>
                          </div>
                        </>
                      )}
                    </div>
                  );
                  })}
                </div>
              )}
            </div>
          </div>
          
          <div className="modal-footer">
            <Dialog.Close asChild>
              <button className="cancel-button">Close</button>
            </Dialog.Close>
          </div>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
};

export default WorkspaceModal;
